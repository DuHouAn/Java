Java提供了两种锁机制来控制多个线程对共享资源的互斥访问，
第一个是JVM实现的synchronized,
而另一个是JDK实现的ReentrantLock.

一、synchronized和ReentrantLock比较

1、锁的实现
synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。

2、性能
新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 性能大致相同。

3、等待可中断（当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。）
ReentrantLock 可中断，而 synchronized 不行。

4、公平锁（公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。）
synchronized 中的锁是非公平的，
ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

5、锁绑定多个条件
一个 ReentrantLock 可以同时绑定多个 Condition 对象。

二、使用选择
除非需要使用 ReentrantLock （Jdk1.5之后）的高级功能，否则优先使用 synchronized。
这是因为
（1）synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。
（2）并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。


<th class="center" width="10%">
						<input type="hidden" id="zjbh${s.count}" name="zjbh${s.count}" value="${i.BH}" />
						<input type="text" id="zjxm${s.count}" value="${i.ZCRY }" style="width: 70%" disabled="disabled">
					</th>