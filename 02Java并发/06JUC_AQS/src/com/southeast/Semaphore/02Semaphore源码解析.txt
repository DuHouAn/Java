1、Semaphore有两种模式:
公平模式和非公平模式。
公平模式就是调用acquire的顺序就是获取许可证的顺序，遵循FIFO；
非公平模式是抢占式的，也就是有可能一个新的获取线程恰好在一个许可证释放时得到了这个许可证，而前面还有等待的线程。

Semaphore有两个构造方法，如下：
       public Semaphore(int permits) {
        sync = new NonfairSync(permits);
    }

    public Semaphore(int permits, boolean fair) {//第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。
        sync = fair ? new FairSync(permits) : new NonfairSync(permits);
    }

Semaphore内部基于AQS的共享模式，所以实现都委托给了Sync类。
这里就看一下NonfairSync的构造方法：
 NonfairSync(int permits) {
            super(permits);
        }

可以看到直接调用了父类的构造方法，Sync的构造方法如下：
Sync(int permits) {
            setState(permits);
        }
可以看到调用了setState方法，也就是说===AQS中的资源就是许可证的数量======。

2、获取许可（非公平模式）

//acquire也有几个重载方法
public void acquire(int permits) throws InterruptedException {
        if (permits < 0) throw new IllegalArgumentException();
        sync.acquireSharedInterruptibly(permits);
    }

从上面可以看到，调用了Sync的acquireSharedInterruptibly方法，该方法在父类AQS中
public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        //如果线程被中断了，抛出异常
        if (Thread.interrupted())
            throw new InterruptedException();
        //获取许可失败，将线程加入到等待队列中
        if (tryAcquireShared(arg) < 0)
            doAcquireSharedInterruptibly(arg);
    }

protected int tryAcquireShared(int acquires) {
            return nonfairTryAcquireShared(acquires);
        }

final int nonfairTryAcquireShared(int acquires) {
            for (;;) {
                //获取剩余许可数量
                int available = getState();
                //计算给完这次许可数量后的个数
                int remaining = available - acquires;
                //如果许可不够或者可以将许可数量重置的话，返回
                if (remaining < 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }

从上面可以看到，
只有在许可不够时返回值才会小于0，其余返回的都是剩余许可数量，这也就解释了，一旦许可不够，后面的线程将会阻塞。

3、获取许可（公平模式）
protected int tryAcquireShared(int acquires) {
            for (;;) {
                //如果前面有线程在等待，直接返回-1
                if (hasQueuedPredecessors()) //===这里与NonFairSync的最大不同
                    return -1;
                //后面与非公平一样
                int available = getState();
                int remaining = available - acquires;
                if (remaining < 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }
从上面可以看到，FairSync与NonFairSync的区别就在于会首先判断当前队列中有没有线程在等待，
如果有，就老老实实进入到等待队列；
而不像NonfairSync一样首先试一把，说不定就恰好获得了一个许可，这样就可以插队了。

4、释放许可
public void release(int permits) {
        if (permits < 0) throw new IllegalArgumentException();
        sync.releaseShared(permits);
    }
releaseShared方法在AQS中：
public final boolean releaseShared(int arg) {
        //如果改变许可数量成功
        if (tryReleaseShared(arg)) {
            doReleaseShared(); //一旦CAS改变许可数量成功，那么就会调用doReleaseShared()方法释放阻塞的线程。
            return true;
        }
        return false;
    }

protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                //获取当前许可数量
                int current = getState();
                //计算回收后的数量
                int next = current + releases;
                if (next < current) // overflow
                    throw new Error("Maximum permit count exceeded");
                //CAS改变许可数量成功，返回true
                if (compareAndSetState(current, next))
                    return true;
            }
        }

5、总结
Semaphore是信号量，用于管理一组资源。
其内部是基于AQS的共享模式，AQS的状态表示许可证的数量，在许可证数量不够时，线程将会被挂起；
一旦有一个线程释放一个资源，那么就有可能重新唤醒等待队列中的线程继续执行。
