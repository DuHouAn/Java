# 类的生命周期

从类被加载到虚拟机内存中开始，到释放内存总共有 7 个阶段：加载（Loading），验证（Verification），准备(Preparation)，解析（Resolution），初始化（Initialization），使用（Using），卸载（Unloading）。

其中验证，准备，解析三个部分统称为**连接（Linking）**。

## 类加载过程

类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。

类加载过程包括加载、连接和初始化这 3 个阶段。其中连接过程又分为 3 步：验证、准备和解析，所以可以说类加载过程包含了加载、验证、准备、解析和初始化这 5 个阶段。

### 1. 加载

**加载是类加载的一个阶段，注意不要混淆**。

加载过程完成以下三件事：

- 通过类的完全限定名称获取定义该类的二进制字节流。
- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。

其中二进制字节流可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
- 从网络中获取，最典型的应用是 Applet。
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。

### 2. 验证

确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。包括如下验证：

- 文件格式验证：验证字节流是否符合 Class 文件格式规范
- 元数据验证：对字节码描述的信息进行语义分析，保证其描述的信息符合 Java 语言规范的要求
- 字节码验证：通过数据流和控制流分析，确保程序语义是合法的、符合逻辑的。
- 符号引用验证：确保解析动作能正确执行。

### 3. 准备

类变量是被 static 修饰的变量，**准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存**。注意：在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、**静态变量等移动到堆中**，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。

实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。

初始值一般为 0 值，例如下面的类变量 value 的初始值是 0 而不是 123（初始化阶段才会赋值）。

```java
public static int value = 123;
```

如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。

```java
public static final int value = 123;
```

### 4. 解析

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。

其中，符号引用指的是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或字段、方法在内存中的指针或者偏移量**。

### 5. 初始化

初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

&lt;clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：

```java
public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”，因为变量 i 在后面才定义的。
    }
    static int i = 1;
}
```

由于父类的 &lt;clinit>() 方法先执行，也就意味着**父类中定义的静态语句块的执行要优先于子类**。例如以下代码：

```java
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
```

接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit>() 方法。但接口与类不同的是，执行接口的 &lt;clinit>() 方法不需要先执行父接口的 &lt;clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit>() 方法。

虚拟机会保证一个类的 &lt;clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit>() 方法完毕。如果在一个类的 &lt;clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。



## 类初始化时机

### 1. 主动引用

只有主动去使用类才会初始化类。

虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列 6 种情况必须对类进行初始化（加载、验证、准备都会随之发生）：

- 情况 1：遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没有进行过初始
  化，则需要先触发其初始化阶段。能够生成这四条指令的典型 Java 代码场景有：
  - 使用 new 关键字实例化对象的时候。
  - 设置一个类型的静态字段（**被 final 修饰、已在编译期把结果放入常量池的静态字段除外**）的时候。
  - 读取一个类型的静态字段（**被 final 修饰、已在编译期把结果放入常量池的静态字段除外**）的时候。
  - 调用一个类型的静态方法的时候。（ JVM 执行 invokestatic 指令时会初始化类）
- 情况 2：使用 java.lang.reflect 包的方法对类型进行**反射调用**的时候，如果类型没有进行过初始化，则需
  要先触发其初始化。
- 情况 3：当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 情况 4：当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先
  初始化这个主类。
- 情况 5：当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
- 情况 6：当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

### 2. 被动引用

以上 6 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：

- 通过子类引用父类的静态字段，不会导致子类初始化。

  举个例子：

  ```java
  public class SuperClass {
      static {
          System.out.println("SuperClass init!");
      }
  
      public static int value=123;
  }
  ```

  ```java
  public class SubClass extends SuperClass{
      static {
          System.out.println("SubClass init!");
      }
  }
  ```

  ```java
  public class NotInitialization {
      public static void main(String[] args) {
          System.out.println(SubClass.value);
      }
  }
  ```

  输出结果为：

  ```html
  SuperClass init!
  123
  ```

  这是因为对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

- 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，**数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法**（数组类型不通过类加载器创建，它由 JVM 直接创建）。

  举个例子：

  ```java
  public class SuperClass {
      static {
          System.out.println("SuperClass init!");
      }
  
      public static int value=123;
  }
  ```

  ```java
  public class SubClass extends SuperClass{
      static {
          System.out.println("SubClass init!");
      }
  }
  ```

  ```java
  public class NotInitialization {
      public static void main(String[] args) {
          SuperClass[] sca = new SuperClass[10];
      }
  }
  ```

  输出结果为：

  ```html
  没有输出 SuperClass init!
  ```

- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

  举了例子：

  ```java
  public class ConstClass {
      static {
          System.out.println("ConstClass init!");
      }
      public static final String HELLOWORLD = "hello world";
  }
  ```

  ```java
  public class NotInitialization {
      public static void main(String[] args) {
          System.out.println(ConstClass.HELLOWORLD);
      }
  }
  ```

  输出结果为：

  ```html
  hello world
  ```


## loadClass 和 forName

loadClass 和 forName 方法都可以获取 Class 对象，但是两者是有区别的：

- loadClass 得到的是加载阶段的 Class 对象，并没有初始化，例如 Spring 中 Bean 的实例的懒加载就是通过这种方式实现的。
- forName 得到的是初始化阶段的 Class 对象，例如 JDBC 中的数据连接。

## 卸载

卸载类即该类的 Class 对象被 GC。

类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：

- 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

JDK 自带的 BootstrapClassLoader, ExtClassLoader 和 AppClassLoader 负责加载 JDK 提供的类，所以这些类加载器的实例肯定不会被回收。但是我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。



# 类加载器

## 类与类加载器

所有的类都由类加载器加载，加载的作用就是将 .class 文件加载到内存中。

两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。

这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。

## 类加载器分类

从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：

- 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；
- 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。

从 Java 开发人员的角度看，类加载器可以划分得更细致一些：

- 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。
- 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

<div data="modify <--"></div>

## 双亲委派模型

每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。

<div align="center"> <img src="https://github.com/DuHouAn/ImagePro/raw/master/JVM/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png" width="350px"> </div>

### 1. 工作过程

在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。

### 2. 好处

使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

可以避免多份同样的字节码的加载。

例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。

### 3. 实现

以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。

```java
public abstract class ClassLoader {
    // The parent class loader for delegation
    private final ClassLoader parent;

    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }

    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            // 首先，自底向上地检查请求的类是否已经被加载过
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        //自顶向下尝试加载该类
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // 在父加载器中无法加载再尝试自己加载
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }

    protected Class<?> findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
}
```

## 自定义类加载器实现

以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。

java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。

```java
public class FileSystemClassLoader extends ClassLoader {

    private String rootDir;

    public FileSystemClassLoader(String rootDir) {
        this.rootDir = rootDir;
    }

    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] classData = getClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException();
        } else {
            return defineClass(name, classData, 0, classData.length);
        }
    }

    private byte[] getClassData(String className) {
        String path = classNameToPath(className);
        try {
            InputStream ins = new FileInputStream(path);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int bufferSize = 4096;
            byte[] buffer = new byte[bufferSize];
            int bytesNumRead;
            while ((bytesNumRead = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesNumRead);
            }
            return baos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private String classNameToPath(String className) {
        return rootDir + File.separatorChar
                + className.replace('.', File.separatorChar) + ".class";
    }
}
```

# 补充

- [main() 方法详解](https://www.cnblogs.com/bingyimeiling/p/10409728.html)